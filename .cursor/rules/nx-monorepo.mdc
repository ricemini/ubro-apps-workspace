# Nx Monorepo Best Practices

## üèóÔ∏è Nx Monorepo Best Practices

### Project Organization

- **Domain-Driven Design**: Organize libraries by business domains, not technical layers
- **Clear Boundaries**: Use Nx module boundaries to enforce architectural constraints
- **Shared Libraries**: Extract common functionality into shared libraries with clear APIs
- **Dependency Management**: Minimize cross-project dependencies and avoid circular dependencies

### Dependency Management Strategy

**Root package.json Rules:**

- Use exclusively for dependencies shared across the entire monorepo
- Include core development tools: Vitest, Playwright, ESLint, Prettier, TypeScript
- Include Nx plugins: @nx/angular, @nx/react, @nx/next, @nx/eslint
- Include workspace management tools: pnpm, husky, lint-staged, commitlint
- **Never** add project-specific dependencies here

**Project package.json Rules:**

- Each app and library must have its own package.json file
- List only direct, specific dependencies required by that particular project
- Examples: @angular/material for Angular apps, @next/font for Next.js apps
- Keep dependencies self-contained and minimal

**Dependency Management Workflow:**

1. Determine if dependency is monorepo-wide tool or project-specific library
2. Place in appropriate package.json file (root vs project)
3. Run `pnpm install` from root to update pnpm-lock.yaml correctly
4. Always prioritize keeping root package.json clean

**Enforcement Guidelines:**

- If asked to add project-specific dependency to root, redirect to project package.json
- Remind of these rules when dependencies seem misplaced
- Ensure each project's dependencies are self-contained
- Maintain clean separation between workspace tools and project dependencies

### Performance & Caching

- **Incremental Builds**: Leverage Nx's intelligent caching for faster builds
- **Affected Commands**: Use `nx affected` to only run tasks on changed projects
- **Parallel Execution**: Configure appropriate parallelism for CI/CD pipelines
- **Build Optimization**: Use production builds with tree-shaking and code splitting

### Development Workflow

- **Consistent Commands**: Use standardized Nx commands across the workspace
- **Type Safety**: Enable strict TypeScript checking across all projects
- **Testing Strategy**: Implement unit, integration, and E2E tests with proper coverage
- **Code Quality**: Use ESLint, Prettier, and other tools consistently

## üêõ Nx-Specific Issues

### Common Nx Problems

- **Circular Dependencies**: Use module boundaries to prevent circular imports
- **Build Performance**: Use affected commands and caching effectively
- **Project Dependencies**: Keep dependencies minimal and well-defined
- **Type Safety**: Ensure consistent TypeScript configuration across projects